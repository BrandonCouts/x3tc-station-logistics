#name: anarkis.ads.cmd.protectgrid
#lang: 44
#origin_mod: ADS
#source: mods/ADS/scripts/anarkis.ads.cmd.protectgrid.xml

* ===========================================
* CMD : Defense Grid - Interrupt Cmd : Protect Sector
* ===========================================
* - Should work for both AI and player owned ships
* - Jump beacon support
* ===========================================

skip if $tg.sector -> exists
return null

$previous.sector = [SECTOR]
[THIS] -> set local variable: name='anarkis.ads.grid.busy' value=[TRUE]
= [THIS] -> call script anarkis.lib.shipstate.save :  ship=[THIS]

$string = sprintf: fmt='(ADS) %s Jump to protect %s', [THIS], $tg.sector, null, null, null
= [THIS] -> call script anarkis.debug.output :  msg=$string

* =====
* Energy Handling
$energy.needed = [THIS] -> needed jump drive energy for jump to sector $tg.sector
$v1 = [THIS] -> get amount of ware Energy Cells in cargo bay
$energy.needed = $energy.needed - $v1
$free.space = [THIS] -> get free amount of ware Energy Cells in cargo bay
if $free.space < $energy.needed
$string = sprintf: fmt='(ADS) Grid - %s can't jump to %s : Not enough cargo space for fuel', [THIS], $tg.sector, null, null, null
= [THIS] -> call script anarkis.debug.output :  msg=$string
[THIS] -> set local variable: name='anarkis.ads.grid.busy' value=null
return [FALSE]
end
* Player has to pay, not the AI. Pay the double price. for going and wayback.
* All expenses are here to prevent ships from behind stuck where they shouldn't be
if [OWNER] == Player
$pl.money = get player money
$price = get average price of ware Energy Cells
$price = $price * 4 * $energy.needed
* - Check for funds
if $price > $pl.money
$string = sprintf: fmt='(ADS) Grid - %s can't jump to %s : Not enough money', [THIS], $tg.sector, null, null, null
= [THIS] -> call script anarkis.debug.output :  msg=$string
[THIS] -> set local variable: name='anarkis.ads.grid.busy' value=null
return [FALSE]
end
$price = 0 - $price
add money to player: $price
end
= [THIS] -> add $energy.needed units of Energy Cells
* =====

$string = sprintf: fmt='(ADS) %s jump to protect %s', [THIS], $tg.sector, null, null, null
= [THIS] -> call script anarkis.debug.output :  msg=$string


$attacker.owner = $attacker -> get true owner
skip if $attacker.owner
$attacker.owner = $attacker -> get owner race

$previous.relation = [THIS] -> get relation to race $attacker.owner
[THIS] -> set relation against $attacker.owner to Foe

* =====
* Do the jump
if [SECTOR] != $tg.sector
$beacon =  find ship: sector=$tg.sector class or type=Jump Beacon race=[OWNER] flags=[Find.Random] refobj=null maxdist=null maxnum=1 refpos=null
if $beacon
= [THIS] -> call script anarkis.lib.cmd.jumptobeacon :  jump.beacon=$beacon
else
$gate =  find gate: flags=[Find.Nearest], refobj=$attacker, max dist=null, refpos=null
*$gate =  get next gate on route from $tg.sector to [SECTOR]
= [THIS] -> call script !ship.cmd.jump.std :  target gate or sector=$gate  followers should jump too=[TRUE]
end
end
* =====


* =====
* Battling Part - room for improvement
if $attacker -> exists
= [THIS] -> call script !ship.cmd.attack.std :  the victim=$attacker  do not follow in new sector=[TRUE]
end
$my.pos = [THIS] -> get position as array
= [THIS] -> call script anarkis.lib.cmd.killandland.timeout :  object to land on=null  the range=100000  refpos array   x y z=$my.pos  no idle, simply stand still=null  timeout=360

while [THIS] -> get local variable: name='anarkis.acc.battle'
= [THIS] -> call script !move.idle.timeout :  timeout in sec=30  wait while docked=[FALSE]
end
* =====

* =====
* Restore previous settings and go back to original sector
[THIS] -> set relation against $attacker.owner to $previous.relation
$energy.needed = [THIS] -> needed jump drive energy for jump to sector $previous.sector
= [THIS] -> add $energy.needed units of Energy Cells

skip if [SECTOR] == $previous.sector
= [THIS] -> call script !move.jumptosector :  sector=$previous.sector  should followers jump too=[TRUE]

[THIS] -> set local variable: name='anarkis.ads.grid.busy' value=null
= [THIS] -> call script anarkis.lib.shipstate.restore :  ship=[THIS]
* =====

return [TRUE]
